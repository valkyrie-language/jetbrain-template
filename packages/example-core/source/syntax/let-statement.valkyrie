⍝ let pattern
let x = expression();
let x, y = expression();
let ref x, mut y = expression();
let (ref x, mut y) = expression();
let Some(x) = expression();
let [x, y, z] = expression();
let Object {x} = expression();
⍝ let pattern typed
let x: bool = expression();
let x, y: (bool, bool) = expression();
let ref x, mut y: (bool, bool) = expression();
let (ref x, mut y): (bool, bool) = expression();
let Some(x: bool): Option⟨bool⟩ = expression();
let [x, y, z]: List⟨bool⟩ = expression();
let Object {x}: Object = expression();
⍝ let pattern binding
let a ← Some(x) = expression();
let ref a ← [x, y, z] = expression();
let mut a ← Object {x, y ← Some(z)} = expression();
⍝ let pattern typed binding
let a ← Some(x): Option⟨bool⟩ = expression();
let ref a ← [x, y, z]: List⟨bool⟩ = expression();
let mut a ← Object {x}: Object = expression();

let Some(a): Option⟨bool⟩ ?= expression()
if a is null {
    return "early"
}
@null_return(a, b != 0)

if a is null {
    return
}

a ?: a;




let Some(a) ?= expression(args)
# a? is avaliable here


try let Some(a) = expression(args) else {
    # bind failed
};
# a! is avaliable here

try let a ← Some(b: bool): Option⟨bool⟩ = expression() { closure } if b is not true else {
    print("require Some(true)")
}
print(a)
print(b)



expression(args) ?: 0

match expression(args) {
    case Some(a):
        a
    case None:
        print("missing a")
        0
}





if expression() is not Some(Integer) {
    print("require Integer")
}

# try not Some(Integer) = expression() then {
#     print("require Integer")
# }


scope {
    # let a ?= expression;
    let [] ?= expression;
    let () ?= expression;
    let (a) ?= expression;
    let Some(a) ?= expression;
    let Object {a} ?= expression;
    # let Object {a, b: Option⟨bool⟩ ?= Some(b)} = expression;
}

# let! Some(x) = X;
let Some(x) ?= x;
#
try let Some(x) = X else {

}
# if x > 0 {
#     x.method()
# }

try let Some(x) = x else {
    @panic
}
